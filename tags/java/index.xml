<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on Shubham Utwal</title>
    <link>https://shubhamutwal.in/tags/java/</link>
    <description>Recent content in java on Shubham Utwal</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>&amp;copy; &lt;a href=&#34;https://shubhamutwal.in&#34;&gt;Shubham Utwal&lt;/a&gt; 2021</copyright>
    <lastBuildDate>Sat, 29 Jan 2022 18:40:02 +0530</lastBuildDate>
    
	<atom:link href="https://shubhamutwal.in/tags/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Using CompletableFuture for parallelism, and variants of ThreadPoolExecutors</title>
      <link>https://shubhamutwal.in/posts/parallelism-in-java/</link>
      <pubDate>Sat, 29 Jan 2022 18:40:02 +0530</pubDate>
      
      <guid>https://shubhamutwal.in/posts/parallelism-in-java/</guid>
      <description>Completable Futures &amp;amp; ForkJoinPool CompletableFutures prove useful in areas where one has to perform multiple tasks in a parallel manner, probably wait on them and combine the results.
By default, the CompletableFuture implementation makes use of the commonPool provided by the ForkJoinPool framework. The distinguishing thing between other ThreadPoolExecutors &amp;amp; ForkJoinPool is the workStealing implementation.
Quoting the docs -
 all threads in the pool attempt to find and execute tasks submitted to the pool and/or created by other active tasks (eventually blocking waiting for work if none exist).</description>
    </item>
    
  </channel>
</rss>